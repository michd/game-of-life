(function (GOL, btoa, atob) {
  // We're encoding data into ascii (1-256), so anything inside that range
  // cannot be used as a delimiter
  // Because of the way utf8 is encoded to base64, we're not using something
  // non-ascii as the delimiter, which further makes the result smaller
  var LINE_DELIMITER = String.fromCharCode(0),
      LINE_NO_DELIMITER = String.fromCharCode(1);

  var encoder = GOL.namespace("sharing.gridEncoder");

  function base64Encode(str) {
    return encodeURIComponent(btoa(unescape(encodeURIComponent(str))));
  }

  function base64Decode(str) {
    return decodeURIComponent(escape(atob(decodeURIComponent(str))));
  }

  // Given an array of boolean values, returns an array of numbers.
  // These numbers represent byte-format portions of the given bools
  function splitToBytes(row) {
    var chunks = [],
        bytes = [],
        i, iMax;

    function convertToByte(chunk) {
      var i,
          value = 0;

      for (i = chunk.length - 1; i >= 0; i--) {
        value += Math.pow(2, chunk.length - 1 - i) * (chunk[i] ? 1 : 0);
      }

      return value;
    }

    row = row.slice(0); // Make shallow copy as we'll alter this
    while (row.length > 0) chunks.push(row.splice(0, 8));

    for (i = 0, iMax = chunks.length; i < iMax; i++) {
      bytes.push(convertToByte(chunks[i]));
    }

    return bytes;
  }

  encoder.encode = function (grid, width, height) {
    var x, xMax,
        b, bMax,
        lines = [],
        lineBytes,
        line,
        encodedGrid = "";

    function sum(arr) {
      var i, iMax,
          total = 0;

      for (i = 0, iMax = arr.length; i < iMax; i++) total += arr[i];

      return total;
    }

    for (x = 0, xMax = grid.length; x < xMax; x++) {
      // Convert the row to a set of numbers, each number representing 8 or less
      // booleans in the grid
      lineBytes = splitToBytes(grid[x]);

      if (sum(lineBytes) === 0) {
        // Do not waste space on empty lines
        continue;
      }

      line = x.toString(36) + LINE_NO_DELIMITER;

      // Convert the generated bytes to characters and put them together
      // as a string representing the row
      for (b = 0, bMax = lineBytes.length; b < bMax; b++) {
        // 0 and 1 ar reserved for delimiters, so add 2 to generated ascii code
        line += String.fromCharCode(lineBytes[b] + 2);
      }

      // Add the converted row to our array
      lines.push(line);
    }

    encodedGrid = lines.slice(0);
    // Prepend width and height to our array
    // radix 36 is optimal enough for space-efficiency
    encodedGrid.unshift(width.toString(36), height.toString(36));
    // Put it all together as one string and encode it to something url-friendly
    return base64Encode(encodedGrid.join(LINE_DELIMITER));
  };

  encoder.decode = function (encodedStr) {
    var outGridInfo = {
        grid: null,
        width: 0,
        height: 0
      },
    encodedGrid = base64Decode(encodedStr).split(LINE_DELIMITER),
    x, xMax;

    function pad(inStr, desiredLength) {
      if (inStr.length === desiredLength) return inStr;
      return new Array(desiredLength - inStr.length + 1).join('0') + inStr;
    }

    function getEmptyRow() {
      var outArr = [],
          i;

      for (i = 0; i < outGridInfo.height; i++) outArr.push(false);

      return outArr;
    }

    function addBlankRows(amount) {
      for (var i = 0; i < amount; i++) {
        outGridInfo.grid.push(getEmptyRow());
      }
    }

    function decodeBytes(bytes) {
      var i, iMax,
          j, jMax,
          bin,
          outArr = [],
          lineArr,
          lineNo;

      for (i = 0, iMax = bytes.length; i < iMax; i++) {
        bin = bytes[i].toString(2);

        bin = pad(
            bin,
            (i < iMax - 1) ? 8 : (outGridInfo.height - outArr.length));

        for (j = 0; j < bin.length; j++) outArr.push(bin[j] === '1');
      }

      return outArr;
    }

    function decodeToBytes(str) {
      var outBytes = [],
          i, iMax;

      for (i = 0, iMax = str.length; i < iMax; i++) {
        outBytes.push(str.charCodeAt(i) - 2);
      }

      return outBytes;
    }

    outGridInfo.width = parseInt(encodedGrid.shift(), 36);
    outGridInfo.height = parseInt(encodedGrid.shift(), 36);

    outGridInfo.grid = [];

    for (x = 0; x < outGridInfo.width; x++) {
      lineArr = encodedGrid.shift().split(LINE_NO_DELIMITER);
      lineNo = parseInt(lineArr.shift(), 36);

      if (lineNo > outGridInfo.grid.length) {
        addBlankRows(lineNo - outGridInfo.grid.length);
      }

      outGridInfo.grid.push(decodeBytes(decodeToBytes(lineArr.shift())));

      if (encodedGrid.length === 0) break;
    }

    if (outGridInfo.grid.length < outGridInfo.width) {
      addBlankRows(outGridInfo.width - outGridInfo.grid.length);
    }

    return outGridInfo;
  };
}(window.GOL, window.btoa, window.atob));
